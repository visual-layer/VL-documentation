---
title: "Custom Metadata"
description: "Developer guide for importing custom metadata using user-defined fields to enhance dataset search and filtering."
---

<Card title="How this Helps" icon="lightbulb">
Add custom metadata like temperature, timestamps, and tools to images via the API. This will help you improve dataset filtering and searchability.
</Card>

---

# Overview

This guide explains how to import custom metadata to your datasets via the API. Each metadata field is user-defined and supports one of several data types.

Custom metadata is associated at the image level and is immutable once uploaded.

To import custom metadata in Visual Layer, you must:
- Declare a metadata field (name + type)
- Upload a JSON file containing values for that field
> ⚠️ All API requests on Cloud environment require authentication using a valid API token.

### Supported value types include:
- `string`
- `float`
- `datetime` (UTC format)
- `enum` (single or multi-select)
- `link`

> ⚠️ Each upload task handles **one field** only. You can declare multiple fields (even of the same type), but each must have a **unique `field_name`**.

---

# Steps

1. Ensure your dataset is in a `READY` state.
2. Declare a new metadata attribute (`field_name`, `field_type`, etc.).
3. Receive a `task_id` for that declaration.
4. Upload metadata values in a JSON file.
5. Track the ingestion progress via the status endpoint.
6. Metadata becomes available for filtering and retrieval.

---

## Preparing the JSON File

To upload custom metadata, you'll need to associate values with the correct media items in your dataset.

Each entry must include:
- A `media_id` – a unique identifier generated by Visual Layer for each image
- A `value` – the metadata value for that image

### How to get `media_id`s

1. **Export your dataset** from the Visual Layer platform.
2. The exported JSON file will include all image-level metadata, including the `media_id` assigned to each media item.
3. Use these `media_id`s to match your custom metadata with the corresponding images.

You can now create your custom metadata file using this structure:

```json
[
  { "media_id": "f3e3d00c-1a8e-4a58-85dc-cdea7a8365a0", "value": "Sunny" },
  { "media_id": "b1ac12e7-53dc-4c7c-b93d-1836b4aa4f95", "value": "Cloudy" }
]
```
--- 

# Step 1: Declare a New Metadata Field
Each declaration creates a new upload task for a **single field**. You can repeat the process to add more fields—just ensure each `field_name` is unique within the dataset.


```http
POST /api/v1/datasets/{dataset_id}/custom_metadata/tasks
```

## Request Body 

### For `string`, `float`, `datetime`, `link`

```json
{
  "field_name": "lighting_condition",
  "field_type": "sring"
}
```

### For `enum`

**`is_multi = false`**

```json
{
  "field_name": "lighting_condition",
  "field_type": "enum",
  "enum_options": ["Sunny", "Cloudy", "Indoor"],
  "is_multi": false
}
```

**`is_multi = true`**
```json
{
  "field_name": "multi_colors",
  "field_type": "enum",
  "enum_options": [
    "red", "green", "blue", "yellow", "purple"
  ],
  "is_multi": true
}
```

The is_multi flag determines whether each image can have one or multiple values from the enum options.

- is_multi: false (Each image can have only one value.)
- is_multi: true (Each image can have multiple values.)


## Response Body:
```json
{
  "task_id": "1234e567-e89b-12d3-a456-426614174000",
  "status": "INIT"
}
```

---

# Step 2: Upload Metadata File
Use the received `task_id` to upload your metadata file. Each entry must include a valid `media_id` and a `value` matching the declared field type.

```http
POST /api/v1/datasets/{dataset_id}/custom_metadata/tasks/{task_id}
```

## Upload Format 

### For `string`, `float`, `datetime`, `link`
```json
[
  { "media_id": "f3e3d00c-1a8e-4a58-85dc-cdea7a8365a0", "value": 23.5 },
  { "media_id": "b1ac12e7-53dc-4c7c-b93d-1836b4aa4f95", "value": 24.0 }
]
```

### For `enum` - when `is_multi = false`
```json
[
  {
    "media_id": "2283963d-6c78-442e-9606-352ab1c30e64",
    "value": "yellow"
  }
]


### For `enum` - when `is_multi = true`
```json
[
  {
    "media_id": "346ba239-5422-475c-aba3-afffc984c13a",
    "value": [
      "black",
      "yellow",
      "blue",
      "pink"
    ]
  }
]
```
---

# Step 3: Check Upload Status

Track progress and get visibility into errors (e.g., type mismatches).

```http
GET /api/v1/datasets/{dataset_id}/custom_metadata/tasks/{task_id}/status
```

### Response Example:
```json
{
  "task_id": "...",
  "status": "COMPLETED_WITH_ERRORS",
  "progress": 100.0,
  "inserted_rows": 6535,
  "error_count": 594,
  "sample_errors": [
    { "reason": "Expected String", "row_index": 17 }
  ]
}
```

---

# Step 4: Retrieve Metadata

### List Declared Metadata Fields

```http
GET /api/v1/datasets/{dataset_id}/custom_metadata/schema
```

Returns all declared fields and types.

### Get Metadata for an Image

```http
GET /api/v1/datasets/{dataset_id}/image/{image_id}/custom_metadata
```

Response:
```json
[
  {
    "field_name": "lighting",
    "field_type": "enum",
    "value": "Sunny"
  },
  {
    "field_name": "temperature",
    "field_type": "float",
    "value": 23.5
  }
]
```

---

## Notes
- Only supported at the **image level** (not object-level—yet).
- Metadata is **immutable** and cannot be updated or replaced
- Each field must have a **unique name** per dataset.
- Multiple fields of the same type are supported, each via a separate task.

